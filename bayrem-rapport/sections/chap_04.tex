\chapter{Implémentation Avancée: Chatbot IA, Blog et DevOps}

\section{Introduction}
Ce chapitre présente l'implémentation avancée de la plateforme MyLoc, couvrant le système d'emails avec exemples concrets, l'intégration du chatbot IA avec ChatGPT, le système de blog et commentaires, ainsi que les aspects DevOps avec Docker, Kubernetes et CI/CD. Cette phase correspond aux \textbf{Sprints 6-8} du planning Scrum.

Les objectifs de cette phase incluent:
\begin{itemize}
    \item Finalisation du système d'emails avec contrats PDF et QR codes.
    \item Intégration du chatbot IA avec l'API ChatGPT.
    \item Développement du système de blog et commentaires.
    \item Containerisation avec Docker.
    \item Déploiement sur Kubernetes (Minikube).
    \item Configuration du pipeline CI/CD avec GitLab.
\end{itemize}

\section{Récapitulatif des Modules Implémentés}
L'application est organisée en composants modulaires correspondant à des fonctionnalités spécifiques, rôles utilisateurs et workflows. Chaque module est indépendamment testable, scalable et maintenu en alignement avec l'architecture microservices.

\subsection{Module d'Authentification (Keycloak)}
\begin{itemize}
    \item Le contrôle d'accès basé sur les rôles est implémenté via Keycloak.
    \item Les utilisateurs sont authentifiés via OAuth2 et reçoivent des tokens JWT.
    \item L'Angular AuthGuard protège les tableaux de bord Admin, Agence et Client.
    \item Les routes du backend Spring Boot sont sécurisées avec des annotations basées sur les rôles (\texttt{@PreAuthorize}, \texttt{@RolesAllowed}).
\end{itemize}

\subsection{Module Administrateur}
\begin{itemize}
    \item Ajouter, modifier et supprimer des agences.
    \item Gérer les clients et les blogs (opérations CRUD).
    \item Consulter et gérer toutes les réservations.
    \item Communiquer avec les agences via le chat en temps réel.
\end{itemize}

\subsection{Module Agence}
\begin{itemize}
    \item Ajouter, modifier et supprimer des voitures.
    \item Télécharger des photos pour les voitures existantes.
    \item Gérer la disponibilité et les demandes de réservation.
    \item Accepter ou refuser les demandes de location, déclenchant emails et notifications.
    \item Communiquer avec l'admin via l'interface de chat en temps réel.
\end{itemize}

\subsection{Module Client}
\begin{itemize}
    \item Parcourir les voitures disponibles et les blogs.
    \item S'inscrire et se connecter avec Keycloak (ou naviguer en tant que visiteur).
    \item Soumettre des demandes de location pour les voitures disponibles.
    \item Recevoir des notifications et emails lors des changements de statut.
    \item Consulter l'historique des locations et supprimer les demandes non confirmées.
    \item Commenter les annonces de voitures et les blogs.
    \item Recevoir un contrat PDF avec QR code après confirmation du paiement.
\end{itemize}

\section{Sprint 6: Intégration du Chatbot IA}

\subsection{Architecture du Chatbot}
Le chatbot est implémenté comme un microservice séparé utilisant Flask et l'API GPT d'OpenAI.

\subsubsection{Stack Technologique}
\begin{itemize}
    \item \textbf{Framework}: Flask (Python)
    \item \textbf{API IA}: OpenAI ChatGPT (GPT-3.5 ou GPT-4)
    \item \textbf{Communication}: REST API avec le frontend Angular
    \item \textbf{Langues}: Support multilingue (Français et Anglais)
\end{itemize}

\subsubsection{Implémentation Flask du Chatbot}
\begin{verbatim}
from flask import Flask, request, jsonify
from flask_cors import CORS
import openai

app = Flask(__name__)
CORS(app)

openai.api_key = os.environ.get('OPENAI_API_KEY')

# Contexte système pour le chatbot MyLoc
SYSTEM_CONTEXT = """
Tu es l'assistant virtuel de MyLoc, une plateforme de location de voitures.
Tu peux aider les utilisateurs à:
- Trouver des voitures disponibles
- Comprendre le processus de réservation
- Répondre aux questions sur les tarifs
- Expliquer les conditions de location
- Fournir des informations sur les agences
Réponds de manière professionnelle et utile.
"""

@app.route('/api/chat', methods=['POST'])
def chat():
    data = request.json
    user_message = data.get('message', '')
    
    try:
        response = openai.ChatCompletion.create(
            model="gpt-3.5-turbo",
            messages=[
                {"role": "system", "content": SYSTEM_CONTEXT},
                {"role": "user", "content": user_message}
            ],
            max_tokens=500,
            temperature=0.7
        )
        
        bot_response = response.choices[0].message.content
        return jsonify({"response": bot_response, "status": "success"})
        
    except Exception as e:
        return jsonify({"response": "Désolé, une erreur est survenue.", 
                       "status": "error"}), 500

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
\end{verbatim}

\subsubsection{Intégration Angular du Chatbot}
Le composant Angular communique avec le service chatbot:

\begin{verbatim}
// chatbot.service.ts
@Injectable({ providedIn: 'root' })
export class ChatbotService {
  private apiUrl = environment.chatbotApiUrl;

  constructor(private http: HttpClient) {}

  sendMessage(message: string): Observable<ChatResponse> {
    return this.http.post<ChatResponse>(`${this.apiUrl}/api/chat`, {
      message: message
    });
  }
}

// chatbot.component.ts
@Component({
  selector: 'app-chatbot',
  templateUrl: './chatbot.component.html'
})
export class ChatbotComponent {
  messages: Message[] = [];
  userInput: string = '';
  isLoading: boolean = false;

  constructor(private chatbotService: ChatbotService) {}

  sendMessage() {
    if (!this.userInput.trim()) return;
    
    this.messages.push({ text: this.userInput, sender: 'user' });
    this.isLoading = true;
    
    this.chatbotService.sendMessage(this.userInput).subscribe({
      next: (response) => {
        this.messages.push({ text: response.response, sender: 'bot' });
        this.isLoading = false;
      },
      error: () => {
        this.messages.push({ 
          text: 'Erreur de connexion au chatbot', 
          sender: 'bot' 
        });
        this.isLoading = false;
      }
    });
    
    this.userInput = '';
  }
}
\end{verbatim}

\subsubsection{Exemples de Conversations}
\begin{table}[h!]
\centering
\small
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{|p{5cm}|p{7cm}|}
\hline
\rowcolor{gray!20}
\textbf{Question Utilisateur} & \textbf{Réponse du Chatbot} \\
\hline
"Comment puis-je réserver une voiture?" & "Pour réserver une voiture sur MyLoc: 1) Parcourez notre catalogue de voitures. 2) Sélectionnez la voiture souhaitée. 3) Choisissez vos dates de location. 4) Remplissez le formulaire de réservation. 5) Attendez la confirmation de l'agence." \\
\hline
"Quels sont les modes de paiement acceptés?" & "MyLoc accepte plusieurs modes de paiement: cartes bancaires (Visa, Mastercard), paiement en espèces à l'agence, et virements bancaires pour les réservations longue durée." \\
\hline
"Y a-t-il des SUV disponibles?" & "Oui! Nous avons plusieurs SUV disponibles. Utilisez le filtre 'Type de véhicule' et sélectionnez 'SUV' pour voir toutes les options. Les prix varient selon le modèle et la période." \\
\hline
\end{tabular}
\caption{Exemples de Conversations avec le Chatbot}
\end{table}

\section{Sprint 7: Système de Blog et Commentaires}

\subsection{Module Blog}
Le système de blog permet à l'administrateur de publier des articles pour engager les utilisateurs.

\subsubsection{Entité Blog}
\begin{verbatim}
@Entity
@Table(name = "blogs")
public class Blog {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(nullable = false)
    private String title;
    
    @Column(columnDefinition = "TEXT")
    private String content;
    
    private String author;
    private String imageUrl;
    private String category;
    
    @Column(name = "created_at")
    private LocalDateTime createdAt;
    
    @OneToMany(mappedBy = "blog", cascade = CascadeType.ALL)
    private List<Comment> comments;
}
\end{verbatim}

\subsubsection{API Endpoints Blog}
\begin{table}[h!]
\centering
\footnotesize
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{|l|l|p{5cm}|}
\hline
\rowcolor{gray!20}
\textbf{Méthode} & \textbf{Endpoint} & \textbf{Description} \\
\hline
GET & /api/blogs & Liste tous les articles \\
\hline
GET & /api/blogs/\{id\} & Récupère un article par ID \\
\hline
POST & /api/blogs & Crée un nouvel article (Admin) \\
\hline
PUT & /api/blogs/\{id\} & Met à jour un article \\
\hline
DELETE & /api/blogs/\{id\} & Supprime un article \\
\hline
GET & /api/blogs/\{id\}/comments & Liste les commentaires \\
\hline
POST & /api/blogs/\{id\}/comments & Ajoute un commentaire \\
\hline
\end{tabular}
\caption{API Endpoints du Système de Blog}
\end{table}

\subsection{Système de Commentaires}
Les utilisateurs peuvent commenter les articles de blog et les annonces de voitures.

\subsubsection{Entité Comment}
\begin{verbatim}
@Entity
@Table(name = "comments")
public class Comment {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @Column(columnDefinition = "TEXT", nullable = false)
    private String content;
    
    private String authorName;
    private String authorEmail;
    
    @ManyToOne
    @JoinColumn(name = "blog_id")
    private Blog blog;
    
    @ManyToOne
    @JoinColumn(name = "car_id")
    private Voiture car;
    
    @Column(name = "created_at")
    private LocalDateTime createdAt;
    
    private boolean approved;
}
\end{verbatim}

\subsection{Module de Paiement en Ligne}
\begin{itemize}
    \item Lors de l'acceptation d'une réservation, un lien de paiement est envoyé par email.
    \item Le paiement est traité et validé via le backend Spring Boot.
    \item Un PDF avec QR code est généré et envoyé après confirmation du paiement.
    \item Le statut de réservation passe à "confirmed".
\end{itemize}

\section{Système d'Emails et Notifications}
\begin{itemize}
    \item Les clients reçoivent des emails pour les nouvelles voitures, décisions de réservation ou mises à jour.
    \item Les Followers reçoivent des notifications pour les nouvelles annonces.
    \item Les notifications sont stockées en base de données et affichées in-app.
\end{itemize}

\subsubsection{Système de Confirmation par Email}
Lorsqu'une agence approuve une demande de location, le système génère et envoie automatiquement un email de confirmation au client. Cet email contient tous les détails de la réservation et un contrat PDF avec un QR code unique pour vérification.

\textbf{Workflow Email:}
\begin{enumerate}
    \item L'agence clique sur "Approuver" sur une demande en attente.
    \item Le backend génère un contrat PDF avec les détails de la réservation.
    \item Un QR code unique est intégré au PDF pour vérification lors de la récupération.
    \item Le service email envoie la confirmation avec la pièce jointe PDF.
    \item Le client reçoit une notification instantanée (in-app + email).
    \item Le statut de réservation passe de "PENDING" à "APPROVED".
\end{enumerate}

\textbf{Exemple: Email de Confirmation Envoyé au Client}

La Figure~\ref{fig:email_confirmation} montre un exemple réel d'email de confirmation envoyé à un client après l'approbation de sa réservation.

\begin{figure}[h!]
    \centering
    \fbox{
    \begin{minipage}{0.85\textwidth}
    \vspace{0.5cm}
    \begin{center}
    \textbf{\Large Confirmation de Réservation}
    \end{center}
    \vspace{0.3cm}
    
    \textbf{Chèr(e) Notre Client(e),}
    
    \vspace{0.3cm}
    
    \begin{tabular}{ll}
    \textbf{Nom:} & Aloui \\
    \textbf{Email:} & zahidaaloui506@gmail.com \\
    \textbf{Message:} & Votre réservation pour \textbf{CLA A} a été confirmée. \\
    \end{tabular}
    
    \vspace{0.5cm}
    
    Nous vous remercions de votre confiance.
    
    \vspace{0.3cm}
    
    Pour toute question supplémentaire, notre équipe reste à votre disposition.
    
    \vspace{0.5cm}
    
    \begin{center}
    % Note: Add your QR code image here (img/qr-code-example.png)
    % Or use a placeholder box:
    \fbox{\parbox{2.5cm}{\centering\vspace{1cm}\textbf{QR Code}\\\small(Scan at pickup)\vspace{1cm}}}
    
    \small\textit{Scannez ce QR code lors de la récupération du véhicule}
    \end{center}
    
    \vspace{0.3cm}
    
    \hrule
    \vspace{0.2cm}
    \small
    \textit{Cet email a été envoyé automatiquement par la plateforme MyLoc.}
    
    \textit{Ne pas répondre à cet email.}
    \vspace{0.3cm}
    \end{minipage}
    }
    \caption{Example of Booking Confirmation Email with QR Code}
    \label{fig:email_confirmation}
\end{figure}

\textbf{Email Content Details:}
\begin{itemize}
    \item \textbf{Subject Line}: "Confirmation de Réservation - MyLoc Agency"
    \item \textbf{Recipient}: Customer's registered email address.
    \item \textbf{Body}: Personalized message with customer name and car details.
    \item \textbf{Attachment}: PDF contract with complete booking information.
    \item \textbf{QR Code}: Unique identifier for the booking, scannable at vehicle pickup.
\end{itemize}

\textbf{QR Code Verification Process:}
\begin{enumerate}
    \item Customer arrives at the agency to pick up the vehicle.
    \item Agency staff scans the QR code from the email or PDF.
    \item System verifies the booking details and validity.
    \item If valid, the rental process proceeds.
    \item Booking status updates to "IN\_PROGRESS" or "COMPLETED".
\end{enumerate}

\subsubsection{Rejection Email Example}
When an agency declines a rental request, a simple notification email is sent to inform the customer.

\begin{figure}[h!]
    \centering
    \fbox{
    \begin{minipage}{0.85\textwidth}
    \vspace{0.5cm}
    \begin{center}
    \textbf{\Large Notification de Réservation}
    \end{center}
    \vspace{0.3cm}
    
    \textbf{Email:} zahidaaloui506@gmail.com
    
    \vspace{0.5cm}
    
    \textbf{Message:}
    
    Votre réservation pour \textbf{Toyota Corolla} a été refusée.
    
    \vspace{0.5cm}
    
    \hrule
    \vspace{0.2cm}
    \small
    \textit{MyLoc Agency}
    \vspace{0.3cm}
    \end{minipage}
    }
    \caption{Example of Booking Rejection Email}
    \label{fig:email_rejection}
\end{figure}

\textbf{Note:} Contrairement à l'email de confirmation, l'email de rejet n'inclut pas de pièce jointe PDF ni de QR code. C'est une simple notification pour informer le client que sa demande n'a pas été acceptée.

\subsubsection{Email d'Alerte Nouvelle Voiture (Pour les Followers)}
Les Followers qui se sont abonnés via le footer du site reçoivent automatiquement des emails lorsque de nouvelles voitures sont ajoutées à la plateforme.

\begin{figure}[h!]
    \centering
    \fbox{
    \begin{minipage}{0.85\textwidth}
    \vspace{0.5cm}
    \begin{center}
    \textbf{\Large New Car Alert}
    \end{center}
    \vspace{0.3cm}
    
    \textbf{Message:}
    
    \vspace{0.3cm}
    
    A new car \textbf{"Mercedes CLA 200"} has just been added to our agency. Check it out now!
    
    \vspace{0.5cm}
    
    \hrule
    \vspace{0.2cm}
    \small
    \textit{MyLoc Agency - You are receiving this email because you subscribed to our alerts.}
    \vspace{0.3cm}
    \end{minipage}
    }
    \caption{Example of New Car Alert Email for Followers}
    \label{fig:email_follower}
\end{figure}

\textbf{Récapitulatif des Types d'Emails:}
\begin{table}[h!]
\centering
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{|l|c|c|c|}
\hline
\rowcolor{gray!20}
\textbf{Type d'Email} & \textbf{PDF Attaché} & \textbf{QR Code} & \textbf{Destinataire} \\
\hline
Confirmation de Réservation & Oui & Oui & Client \\
\hline
Rejet de Réservation & Non & Non & Client \\
\hline
Alerte Nouvelle Voiture & Non & Non & Followers \\
\hline
\end{tabular}
\caption{Types d'Emails et leur Contenu}
\label{tab:email_types}
\end{table}

\section{Sprint 8: DevOps - Docker, Kubernetes et CI/CD}

\subsection{Containerisation avec Docker}
Chaque composant de la plateforme est containerisé pour assurer la portabilité et la facilité de déploiement.

\subsubsection{Dockerfile Backend (Spring Boot)}
\begin{verbatim}
FROM openjdk:17-jdk-slim
WORKDIR /app
COPY target/myloc-backend.jar app.jar
EXPOSE 8080
ENTRYPOINT ["java", "-jar", "app.jar"]
\end{verbatim}

\subsubsection{Dockerfile Frontend (Angular)}
\begin{verbatim}
# Stage 1: Build
FROM node:20-alpine AS build
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build --prod

# Stage 2: Serve
FROM nginx:alpine
COPY --from=build /app/dist/myloc-frontend /usr/share/nginx/html
COPY nginx.conf /etc/nginx/conf.d/default.conf
EXPOSE 80
CMD ["nginx", "-g", "daemon off;"]
\end{verbatim}

\subsubsection{Dockerfile Chatbot (Flask)}
\begin{verbatim}
FROM python:3.11-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
COPY . .
EXPOSE 5000
CMD ["python", "app.py"]
\end{verbatim}

\subsubsection{Docker Compose}
\begin{verbatim}
version: '3.8'
services:
  frontend:
    build: ./frontend
    ports:
      - "80:80"
    depends_on:
      - backend
    networks:
      - myloc-network

  backend:
    build: ./backend
    ports:
      - "8080:8080"
    environment:
      - SPRING_DATASOURCE_URL=jdbc:mysql://db:3306/myloc
      - SPRING_DATASOURCE_USERNAME=${DB_USER}
      - SPRING_DATASOURCE_PASSWORD=${DB_PASS}
    depends_on:
      - db
    networks:
      - myloc-network

  chatbot:
    build: ./chatbot
    ports:
      - "5000:5000"
    environment:
      - OPENAI_API_KEY=${OPENAI_KEY}
    networks:
      - myloc-network

  db:
    image: mysql:8
    environment:
      - MYSQL_ROOT_PASSWORD=${DB_ROOT_PASS}
      - MYSQL_DATABASE=myloc
    volumes:
      - mysql-data:/var/lib/mysql
    networks:
      - myloc-network

  keycloak:
    image: quay.io/keycloak/keycloak:latest
    ports:
      - "8180:8080"
    environment:
      - KEYCLOAK_ADMIN=admin
      - KEYCLOAK_ADMIN_PASSWORD=${KC_ADMIN_PASS}
    command: start-dev
    networks:
      - myloc-network

networks:
  myloc-network:
    driver: bridge

volumes:
  mysql-data:
\end{verbatim}

\subsection{Déploiement Kubernetes (Minikube)}
Le déploiement sur Kubernetes permet une orchestration avancée des conteneurs.

\subsubsection{Deployment Backend}
\begin{verbatim}
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myloc-backend
  labels:
    app: myloc-backend
spec:
  replicas: 2
  selector:
    matchLabels:
      app: myloc-backend
  template:
    metadata:
      labels:
        app: myloc-backend
    spec:
      containers:
      - name: backend
        image: myloc/backend:latest
        ports:
        - containerPort: 8080
        env:
        - name: SPRING_DATASOURCE_URL
          valueFrom:
            secretKeyRef:
              name: myloc-secrets
              key: db-url
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
---
apiVersion: v1
kind: Service
metadata:
  name: myloc-backend-service
spec:
  selector:
    app: myloc-backend
  ports:
  - port: 8080
    targetPort: 8080
  type: ClusterIP
\end{verbatim}

\subsubsection{Deployment Frontend}
\begin{verbatim}
apiVersion: apps/v1
kind: Deployment
metadata:
  name: myloc-frontend
spec:
  replicas: 2
  selector:
    matchLabels:
      app: myloc-frontend
  template:
    metadata:
      labels:
        app: myloc-frontend
    spec:
      containers:
      - name: frontend
        image: myloc/frontend:latest
        ports:
        - containerPort: 80
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
---
apiVersion: v1
kind: Service
metadata:
  name: myloc-frontend-service
spec:
  selector:
    app: myloc-frontend
  ports:
  - port: 80
    targetPort: 80
  type: LoadBalancer
\end{verbatim}

\subsection{Pipeline CI/CD avec GitLab}
Le pipeline CI/CD automatise le build, les tests et le déploiement.

\subsubsection{Configuration .gitlab-ci.yml}
\begin{verbatim}
stages:
  - build
  - test
  - docker
  - deploy

variables:
  DOCKER_REGISTRY: registry.gitlab.com
  IMAGE_TAG: $CI_COMMIT_SHORT_SHA

# Build Stage
build-backend:
  stage: build
  image: maven:3.9-openjdk-17
  script:
    - cd backend
    - mvn clean package -DskipTests
  artifacts:
    paths:
      - backend/target/*.jar
    expire_in: 1 hour

build-frontend:
  stage: build
  image: node:20-alpine
  script:
    - cd frontend
    - npm ci
    - npm run build --prod
  artifacts:
    paths:
      - frontend/dist/
    expire_in: 1 hour

# Test Stage
test-backend:
  stage: test
  image: maven:3.9-openjdk-17
  script:
    - cd backend
    - mvn test
  dependencies:
    - build-backend

test-frontend:
  stage: test
  image: node:20-alpine
  script:
    - cd frontend
    - npm ci
    - npm run test -- --watch=false --browsers=ChromeHeadless
  dependencies:
    - build-frontend

# Docker Stage
docker-build:
  stage: docker
  image: docker:latest
  services:
    - docker:dind
  script:
    - docker login -u $CI_REGISTRY_USER -p $CI_REGISTRY_PASSWORD $DOCKER_REGISTRY
    - docker build -t $DOCKER_REGISTRY/myloc/backend:$IMAGE_TAG ./backend
    - docker build -t $DOCKER_REGISTRY/myloc/frontend:$IMAGE_TAG ./frontend
    - docker push $DOCKER_REGISTRY/myloc/backend:$IMAGE_TAG
    - docker push $DOCKER_REGISTRY/myloc/frontend:$IMAGE_TAG
  dependencies:
    - build-backend
    - build-frontend

# Deploy Stage
deploy-staging:
  stage: deploy
  image: bitnami/kubectl:latest
  script:
    - kubectl config use-context staging
    - kubectl set image deployment/myloc-backend 
        backend=$DOCKER_REGISTRY/myloc/backend:$IMAGE_TAG
    - kubectl set image deployment/myloc-frontend 
        frontend=$DOCKER_REGISTRY/myloc/frontend:$IMAGE_TAG
    - kubectl rollout status deployment/myloc-backend
    - kubectl rollout status deployment/myloc-frontend
  environment:
    name: staging
  only:
    - develop

deploy-production:
  stage: deploy
  image: bitnami/kubectl:latest
  script:
    - kubectl config use-context production
    - kubectl set image deployment/myloc-backend 
        backend=$DOCKER_REGISTRY/myloc/backend:$IMAGE_TAG
    - kubectl set image deployment/myloc-frontend 
        frontend=$DOCKER_REGISTRY/myloc/frontend:$IMAGE_TAG
  environment:
    name: production
  only:
    - main
  when: manual
\end{verbatim}

\section{Implémentation Base de Données}
La plateforme utilise une base de données relationnelle MySQL. Les entités sont mappées via annotations JPA.

\begin{itemize}
    \item \textbf{Agence Table:} Stores agency profiles and login credentials.
    \item \textbf{Booking Table:} Stores rental requests, dates, customer info, price, and car details.
    \item \textbf{Blog Table:} Contains articles, authors, multimedia content.
    \item \textbf{Voiture Table:} Stores car details (name, type, price, photos).
    \item \textbf{User Table:} Stores customer information and login references.
    \item \textbf{Notification Table:} Stores in-app messages and alert statuses.
\end{itemize}

\section{Screenshots of the Application}
Screenshots illustrate the platform’s functionalities for different user roles:

\begin{itemize}
    \item Tableau de bord admin avec gestion des agences.
    \item Tableau de bord agence avec opérations CRUD voitures.
    \item Page de réservation client et vue historique.
    \item Interface de chat en temps réel admin-agences.
    \item Contrat PDF généré avec QR code.
    \item Interface chatbot intégrée sur la page d'accueil.
\end{itemize}

\begin{figure}[h!]
    \centering
    \includegraphics[width=14cm]{assets/admin-dashboard.png}
    \caption{Tableau de Bord Admin pour la Gestion des Agences}
    \label{fig:admin-dash-ch4}
\end{figure}

\begin{figure}[h!]
    \centering
    \includegraphics[width=14cm]{assets/chatbot-demo.png}
    \caption{Intégration du Chatbot sur la Page d'Accueil}
    \label{fig:chatbot-ch4}
\end{figure}

\section{Tests et Validation}
Le système a été validé à travers des tests manuels et automatisés.

\subsection{Tests Unitaires}
\begin{itemize}
    \item Tests unitaires Spring Boot pour les services et contrôleurs.
    \item Endpoints REST API testés avec Postman.
    \item Tests unitaires Angular utilisant Jasmine et Karma.
\end{itemize}

\subsection{Tests d'Intégration}
\begin{itemize}
    \item Tests end-to-end du flux de réservation de la demande client à la validation agence.
    \item Traitement des paiements, génération PDF et envoi d'emails testés avec des gateways mock.
    \item Fonctionnalité de chat en temps réel testée entre admin et agences.
\end{itemize}

\subsection{Validation Pipeline CI/CD}
\begin{itemize}
    \item Les pipelines GitLab CI testent les processus de build, exécutent les tests unitaires et déploient sur Kubernetes.
    \item Conteneurs Docker testés localement et en environnements de staging.
    \item Procédures de rollback et hotfix validées.
\end{itemize}

\subsection{Témoignages Utilisateurs}
Pour compléter les résultats de tests quantitatifs, nous avons collecté des retours d'utilisateurs réels ayant interagi avec la plateforme:

\begin{itemize}
    \item \textbf{Bassem Ajengui (CEO \& Fondateur):} ``Super application, très intuitive et facile à utiliser. Je recommande vivement !''
    \item \textbf{Assyl Kria (Designer):} ``Franchement, rien à dire ! Les voitures sont top et le service hyper pro.''
    \item \textbf{Bayrem Boussaidi (Propriétaire de Magasin):} ``J'ai adoré la facilité de réservation et la qualité des véhicules proposés.''
    \item \textbf{Aymen Arfaoui (Freelancer):} ``Une des meilleures agences de location de voitures, je reviendrai sans hésiter.''
    \item \textbf{Mouhib Touati (Entrepreneur):} ``Je suis très satisfait du service, les prix sont abordables et les voitures impeccables.''
\end{itemize}

Ces témoignages démontrent une réception positive de multiples rôles utilisateurs, confirmant l'utilisabilité, la clarté et la fiabilité de la plateforme.

\section{Livrables de cette Phase}

\subsection{User Stories Complétées}
\begin{table}[h!]
\centering
\small
\renewcommand{\arraystretch}{1.3}
\begin{tabular}{|c|l|c|}
\hline
\rowcolor{gray!20}
\textbf{ID} & \textbf{User Story} & \textbf{Statut} \\
\hline
\multicolumn{3}{|c|}{\cellcolor{gray!10}\textbf{Sprint 6: Chatbot IA}} \\
\hline
US-23 & Le visiteur interagit avec le chatbot & Fait \\
\hline
US-24 & Le chatbot répond aux questions courantes & Fait \\
\hline
US-25 & Le chatbot supporte le multilingue & Fait \\
\hline
\multicolumn{3}{|c|}{\cellcolor{gray!10}\textbf{Sprint 7: Blog \& Commentaires}} \\
\hline
US-26 & L'admin crée des articles de blog & Fait \\
\hline
US-27 & Le client commente les blogs & Fait \\
\hline
US-31 & Le client commente les voitures & Fait \\
\hline
\multicolumn{3}{|c|}{\cellcolor{gray!10}\textbf{Sprint 8: DevOps}} \\
\hline
US-32 & L'équipe déploie via Docker & Fait \\
\hline
US-33 & L'équipe configure Kubernetes & Fait \\
\hline
US-34 & Le pipeline CI/CD est opérationnel & Fait \\
\hline
US-35 & Les tests automatisés passent & Fait \\
\hline
\end{tabular}
\caption{User Stories Complétées - Sprints 6-8}
\end{table}

\section{Conclusion}
La phase d'implémentation avancée a transformé avec succès la conception en une plateforme web robuste et fonctionnelle. Tous les modules planifiés — de l'authentification et des workflows de réservation à la messagerie en temps réel, notifications email automatisées, support chatbot IA et paiements en ligne — ont été développés, testés et déployés. 

L'infrastructure DevOps avec Docker, Kubernetes et GitLab CI/CD assure une livraison continue et un déploiement fiable. Le système est stable, scalable et fournit une expérience digitale fluide pour tous les rôles utilisateurs.
